         JSON   Материал из Википедии — свободной энциклопедии     Перейти к навигации  Перейти к поиску  JSON       Расширение   .json    MIME -тип   application/json [1]    Тип формата   Обмен данными    Расширен из   JavaScript    Стандарт(ы)   RFC 8259    Сайт   json.org ​ (англ.) json.org/json-fr.… ​ (фр.) json.org/json-it.… ​ (итал.)   Медиафайлы на Викискладе   JSON ( англ.  JavaScript Object Notation , обычно произносится как / ˈ dʒ eɪ s ən / JAY-sən [2] ) — текстовый формат  обмена данными , основанный на JavaScript . Как и многие другие текстовые форматы, JSON легко читается людьми. Формат JSON был разработан Дугласом Крокфордом [3] . Несмотря на происхождение от JavaScript (точнее, от подмножества языка стандарта ECMA-262  1999 года ), формат считается независимым от языка и может использоваться практически с любым языком программирования . Для многих языков существует готовый код для создания и обработки данных в формате JSON.  Содержание   1  Использование  2  Синтаксис  3  JSON5  4  Сравнение с YAML  5  JSON Schema  6  Формат JSON-LD для связанных данных  7  Использование JSON в Ajax  8  Вопросы безопасности   8.1  JavaScript eval()  8.2  Встроенный JSON  8.3  Подделка кроссдоменного запроса    9  JSONP и JSONPP  10  JSONB  11  См. также  12  Примечания  13  Ссылки    Использование [ править | править код ]  За счёт своей лаконичности по сравнению с XML формат JSON может быть более подходящим для сериализации сложных структур.
Применяется в веб-приложениях как для обмена данными между браузером и сервером ( AJAX ), так и между серверами (программные HTTP -сопряжения). Поскольку формат JSON является подмножеством синтаксиса языка JavaScript, то он может быть быстро десериализован встроенной функцией eval() .  Синтаксис [ править | править код ]  JSON-текст представляет собой (в закодированном виде) одну из двух структур:  Набор пар ключ: значение . В различных языках это реализовано как запись , структура , словарь , хеш-таблица , список с ключом или ассоциативный массив . Ключом может быть только строка ( регистрозависимость не регулируется стандартом, это остаётся на усмотрение программного обеспечения. Как правило, регистр учитывается программами — имена с буквами в разных регистрах считаются разными, например [4] ), значением — любая форма. Повторяющиеся имена ключей допустимы, но не рекомендуются стандартом; обработка таких ситуаций происходит на усмотрение программного обеспечения, возможные варианты — учитывать только первый такой ключ, учитывать только последний такой ключ, генерировать ошибку.  Упорядоченный набор значений . Во многих языках это реализовано как массив , вектор , список или последовательность .  Структуры данных, используемые JSON, поддерживаются любым современным языком программирования, что и позволяет применять JSON для обмена данными между различными языками программирования и программными системами. В качестве значений в JSON могут быть использованы:  запись — это неупорядоченное множество пар ключ : значение , заключённое в фигурные скобки «{ }» . Ключ описывается строкой , между ним и значением стоит символ «:» . Пары ключ-значение отделяются друг от друга запятыми.  массив (одномерный) — это упорядоченное множество значений . Массив заключается в квадратные скобки «[ ]» . Значения разделяются запятыми. Массив может быть пустым, то есть не содержать ни одного значения. Значения в пределах одного массива могут иметь разный тип.  число (целое или вещественное).  литералы  true ( логическое значение «истина»), false ( логическое значение «ложь») и null .  строка — это упорядоченное множество из нуля или более символов юникода , заключённое в двойные кавычки. Символы могут быть указаны с использованием escape-последовательностей , начинающихся с обратной косой черты  «\» (поддерживаются варианты \", \\, \/, \t, \n, \r, \f и \b), или записаны шестнадцатеричным кодом в кодировке Unicode в виде \uFFFF.  Строка очень похожа на литерал одноимённого типа данных в языке Javascript . Число тоже очень похоже на Javascript-число, за исключением того, что используется только десятичный формат (с точкой в качестве разделителя). Пробелы могут быть вставлены между любыми двумя синтаксическими элементами. Следующий пример показывает JSON-представление данных об объекте, описывающем человека. В данных присутствуют строковые поля имени и фамилии, информация об адресе и массив, содержащий список телефонов. Как видно из примера, значение может представлять собой вложенную структуру.  {  "firstName" :  "Иван" ,  "lastName" :  "Иванов" ,  "address" :  {  "streetAddress" :  "Московское ш., 101, кв.101" ,  "city" :  "Ленинград" ,  "postalCode" :  101101  },  "phoneNumbers" :  [  "812 123-1234" ,  "916 123-4567"  ]  }   Обратите внимание на пару "postalCode": 101101 . В качестве значений в JSON могут быть использованы как числа, так и строки. Поэтому запись "postalCode": "101101" содержит строку, а "postalCode": 101101 — уже числовое значение. Из-за слабой типизации в Javascript и PHP строка может быть приведена к числу и не влиять на логику программы. Тем не менее, рекомендуется аккуратно обращаться с типом значения, так как JSON служит для межсистемного обмена. На языке XML подобная структура выглядела бы примерно так:  <person>  <firstName> Иван </firstName>  <lastName> Иванов </lastName>  <address>  <streetAddress> Московское ш., 101, кв.101 </streetAddress>  <city> Ленинград </city>  <postalCode> 101101 </postalCode>  </address>  <phoneNumbers>  <phoneNumber> 812 123-1234 </phoneNumber>  <phoneNumber> 916 123-4567 </phoneNumber>  </phoneNumbers>  </person>   или так:  <person  firstName= "Иван"  lastName= "Иванов" >  <address  streetAddress= "Московское ш., 101, кв.101"  city= "Ленинград"  postalCode= "101101"  />  <phoneNumbers>  <phoneNumber> 812 123-1234 </phoneNumber>  <phoneNumber> 916 123-4567 </phoneNumber>  </phoneNumbers>  </person>   JSON5 [ править | править код ]  JSON5 — предложенное расширение формата json в соответствии с синтаксисом ECMAScript 5, вызванное тем, что json используется не только для общения между программами, но и создаётся/редактируется вручную [5] . Файл JSON5 всегда является корректным кодом ECMAScript 5. JSON5 обратно совместим с JSON. Для некоторых языков программирования уже существуют парсеры json5 [6] . Некоторые нововведения:  Поддерживаются как однострочные // , так и многострочные /* */ комментарии.  Записи и списки могут иметь запятую после последнего элемента (удобно при копировании элементов).  Ключи записей могут быть без кавычек, если они являются валидными идентификаторами ECMAScript 5.  Строки могут заключаться как в одинарные, так и в двойные кавычки.  Числа могут быть в шестнадцатеричном виде, начинаться или заканчиваться десятичной точкой, включать Infinity, -Infinity, NaN и -NaN, начинаться со знака +.  Сравнение с YAML [ править | править код ]  Как функционально, так и синтаксически JSON является подмножеством языка YAML . В частности, спецификация YAML 1.2 указывает, что «любой файл в формате JSON является корректным файлом в формате YAML» [7] . Наиболее распространённый парсер YAML способен обрабатывать и JSON [8] . Спецификация YAML до версии 1.2 не полностью покрывала JSON, в первую очередь из-за отсутствия родной поддержки UTF-32 в YAML, а также требования пробела после разделителя-запятой; кроме того, спецификация JSON включала комментарии в стиле /* */. Наиболее важным отличием YAML является набор расширений синтаксиса, которым нет аналогов в JSON:  поддержка реляционных данных: в YAML-документе можно ссылаться на якорь, встретившийся ранее в файле/потоке; таким образом можно выразить рекурсивные структуры .  поддержка расширяемых типов данных помимо примитивов : строк, чисел, логических значений и т. д.  поддержка блочного синтаксиса с отступами; он позволяет описать структурированные данные без использования лишних символов: всевозможных скобок, кавычек и т. д.  JSON Schema [ править | править код ]  JSON Schema — один из языков описания структуры JSON-документа. Использует синтаксис JSON. Базируется на концепциях XML Schema , RelaxNG , Kwalify . JSON Schema — самоописательный язык: при его использовании для обработки данных и описания их допустимости могут использоваться одни и те же инструменты сериализации / десериализации [9] .  Формат JSON-LD для связанных данных [ править | править код ]  Основная статья: JSON-LD  Стандарт JSON не поддерживает ссылки на объекты, но желаемого результата можно достичь при помощи дополнительных соглашений. Рекомендацией W3C для связанных данных является JSON-LD , в котором использована модель данных RDF . В JSON-LD к данным добавляется контекст (context), связывающий свойства объектов JSON-документа с элементами онтологий [10] .  Использование JSON в Ajax [ править | править код ]  Следующий пример Javascript-кода показывает, как браузер может использовать XMLHttpRequest , чтобы запрашивать с сервера объект в формате JSON (серверная часть программы опущена; в ней должен быть размещён код, отправляющий данные в формате JSON-строки в ответ на запросы по url ).  var  http_request  =  new  XMLHttpRequest ();  http_request . onreadystatechange  =  function  ()  {  if  ( http_request . readyState  !==  4 )  return ;  if  ( http_request . status  !==  200 )  throw  new  Error ( 'request was defeated' );  do_something_with_object ( JSON . parse ( http_request . responseText ));  http_request  =  null ;  };  http_request . open ( "GET" ,  url ,  true );  http_request . send ( null );   Заметим, что данный пример применения XMLHttpRequest не поддерживает Internet Explorer до версии 6 включительно, так что для них следует использовать несколько иной код. Возможности применения XMLHttpRequest ограничены из-за правила ограничения домена (same origin policy): URL-ответ на запрос должен находиться в том же DNS-домене, что и сервер, на котором находится страница, запрашивающая ответ. В качестве альтернативы применяется подход JSONP , включающий в себя использование закодированного вызова функции, передающегося между клиентом и сервером, чтобы клиент мог загружать закодированные в JSON данные со сторонних доменов, и уведомлять о завершении вызывающую сторону, хотя это приводит к некоторым рискам для безопасности и дополнительным требованиям к серверу. Как вариант, в коде страницы можно использовать элементы <iframe> для асинхронного запроса JSON-данных, или просто <form action="url_to_cgi_script"> . Эти подходы были распространены до появления широкой поддержки XMLHttpRequest. Также можно использовать для передачи JSON-данных динамические теги <script> . С помощью этого метода можно обойти правило ограничения домена (same origin policy), но он приводит к появлению уязвимого кода. В качестве более безопасной альтернативы было предложено использовать JSONRequest .  Вопросы безопасности [ править | править код ]  Хотя JSON предназначен для передачи данных в сериализованном виде, его синтаксис соответствует синтаксису JavaScript и это создаёт ряд проблем безопасности. Зачастую для обработки данных, полученных от внешнего источника в формате JSON, к ним применяется функция eval() без какой-либо предварительной проверки.  JavaScript eval() [ править | править код ]  Поскольку JSON представляется синтаксически правильным фрагментом кода JavaScript, простейшим способом разбора JSON-данных в JavaScript-программе является использование встроенной в JavaScript функции eval() , которая предназначена для выполнения JavaScript-выражений. При этом подходе отпадает необходимость в использовании дополнительных парсеров. Техника использования eval() делает систему уязвимой, если источник используемых JSON-данных не является доверенным ( англ. ) . В качестве таких данных может выступать вредоносный JavaScript код для атак класса Внедрение кода ( англ. ) . С помощью данной уязвимости возможно осуществлять кражу данных, подделку аутентификации. Тем не менее, уязвимость можно устранить за счёт использования дополнительных средств проверки данных на корректность. Например, до выполнения eval() полученные от внешнего источника данные могут проверяться с помощью регулярных выражений . В RFC , определяющей JSON [11] , предлагается использовать следующий код для проверки его соответствия формату JSON  var  my_JSON_object  =  ! ( /[^,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]/ . test (  text . replace ( /"(\\.|[^"\\])*"/g ,  '' )))  &&  eval ( '('  +  text  +  ')' );   Как более безопасная альтернатива eval() была предложена новая функция JSON.parse() , способная обрабатывать только JSON-данные. Она была представлена в четвёртой версии стандарта ECMAScript и описана в статье «JSON: Обезжиренная альтернатива XML» [12] . В настоящее время она доступна как библиотека JavaScript [13] и была включена в пятую редакцию ECMAScript.  Встроенный JSON [ править | править код ]  Последние версии веб-браузеров имеют встроенную поддержку JSON и способны его обрабатывать без вызова функции eval() , приводящей к вышеописанной проблеме с безопасностью. Обработка JSON в таком случае обычно осуществляется быстрее. Так в июне 2009 года следующие браузеры имели встроенную поддержку JSON:  Mozilla Firefox 3.5+ [14]  Microsoft Internet Explorer 8 [15]  Opera 10.5 + [16]  Браузеры, основанные на WebKit (например, Google Chrome и Apple Safari ) [17]  По крайней мере пять популярных библиотек JavaScript используют встроенный JSON в случае его доступности:  jQuery [18] [19]  Dojo [20]  MooTools [21]  Yahoo! UI Library [22]  Prototype [23]  Подделка кроссдоменного запроса [ править | править код ]  В этом разделе не хватает ссылок на источники информации . Информация должна быть проверяема , иначе она может быть поставлена под сомнение и удалена. Вы можете отредактировать эту статью, добавив ссылки на авторитетные источники . Эта отметка установлена 22 мая 2018 года .  Непродуманное использование JSON делает сайты уязвимыми для подделки межсайтовых запросов (CSRF или XSRF) [24] . Поскольку тег <script> допускает использование источника, не принадлежащего к тому же домену, что и использующий ресурс, это позволяет выполнять код под видом данных, представленных в формате JSON, в контексте произвольной страницы, что делает возможным компрометацию паролей или другой конфиденциальной информации пользователей, прошедших авторизацию на другом сайте. Это представляется проблемой только в случае содержания в JSON-данных конфиденциальной информации, которая может быть компрометирована третьей стороной и если сервер рассчитывает на политику одного источника ( англ. ) , блокируя доступ к данным при обнаружении внешнего запроса. Это не является проблемой, если сервер определяет допустимость запроса, предоставляя данные только в случае его корректности. HTTP cookie нельзя использовать для определения этого. Исключительное использование HTTP cookie используется подделкой межсайтовых запросов .  JSONP и JSONPP [ править | править код ]  JSONP ( англ.  JSON Padding — «JSON с подкладкой») является расширением JSON, когда имя функции обратного вызова указывается в качестве входного аргумента. В основу технологии положен тот факт, что политика безопасности браузера не запрещает использовать тег <script type="text/javascript" src="…"></script> для обращения к серверам, отличным от сервера, с которого произошла загрузка страницы. Без использования технологии JSONP (то есть используя просто JSON кодирование данных) сервер может вернуть только данные. Например, так:  { "paper" :  "A4" ,  "count" :  5 }   Однако это только данные, и они не могут влиять на браузер. Используя технику JSONP, стороннему серверу передаётся в строке вызова (GET) имя callback функции:  <script type="text/javascript" src="http://example.com/getjson?jsonp=parseResponse"></script>  Здесь параметр jsonp содержит имя callback функции parseResponse. Теперь посторонний сервер example.com может вернуть следующий код:  parseResponse ({ "paper" :  "A4" ,  "count" :  5 })   Теперь код вызывает javascript-функцию первого домена. Первоначально идея была предложена в блоге MacPython в 2005 году [25] и в настоящее время используется многими Web 2.0 приложениями, такими, как Dojo Toolkit Applications, Google Toolkit Applications [ https://www.webcitation.org/6Djo88laj?url=http://www.gwtapps.com/?p=42%5d и zanox Web Services. Дальнейшие расширения этого протокола были предложены с учётом ввода дополнительных аргументов, как, например, в случае JSONPP [26] при поддержке S3DB веб-сервисов. Поскольку JSONP использует скрипт теги, вызовы по сути открыты миру. По этой причине JSONP может быть неуместными для хранения конфиденциальных данных [27] . Включение скриптовых тегов от удалённых сайтов позволяет им передать любой контент на сайте. Если удалённый сайт имеет уязвимости, которые позволяют выполнить Javascript инъекции, то исходный сайт также может быть затронут ими. JSONPP ( англ.  parameterized JSON with padding — «параметризованный JSON с подкладкой») — развитие идеи JSONP. JSONPP включает в себя URL источника, имя функции, которая будет обрабатывать JSON данные, строка для eval после получения данных и строка для eval после окончания обработки данных:  JSON_call ( SRC , JSONP , JSONPP , ONLOAD );  в итоге оборачивается ans  =  JSONP ( SRC )  {  eval ( JSONPP ( ans ));  eval ( ONLOAD );  }   Вообще, для самой идеи JSONPP не принципиально количество параметров. Достаточно SRC, JSONP, JSONPP (и их обработка на стороне сервера, а затем клиента) для того, чтобы это был JSONPP. Рассмотрим на примере работы с сервисом S3DB.  function  s3db_jsonpp_call ( src ,  next_eval ){  var  call  =  "call_" + Math . random (). toString (). replace ( /\./g , "" );  var  headID  =  document . getElementsByTagName ( "head" )[ 0 ];  var  script  =  document . createElement ( 'script' );  script . id  =  call ;  script . type  =  'text/javascript' ;  // using padded, parameterized json  src  =  src + "&format=json&jsonp=s3db_jsonpp&jsonpp=" + next_eval + "&onload=remove_element_by_id('" + script . id + "')" ;  script . src  =  src ;  headID . appendChild ( script );  // retrieve answer  }  function  s3db_jsonpp ( ans ,  jsonpp ){  eval ( jsonpp );  return  ans ;  }  function  remove_element_by_id ( id ){  var  e  =  document . getElementById ( id );  e . parentNode . removeChild ( e );  return  false ;  }   В примере функция s3db_jsonpp_call() создаёт в DOM в части head элемент script, src которого соответствует вызову JSONPP. После получения ответа от сервера будет вызвана s3db_jsonpp() — она передана в параметрах вызова, как это должно быть по правилам JSONP. Внутри s3db_jsonpp() сработает eval(jsonpp) , и произойдёт возврат значения ans. Вызов eval(onload) приводит к выполнению remove_element_by_id() с id созданного скрипта в head и в итоге к его удалению, ведь он уже всё равно не будет использоваться, поскольку id в примере было сгенерировано случайным образом в самом начале функции s3db_jsonpp_call() . Этот вызов в ответе сервера.  JSONB [ править | править код ]  Бинарное расширение JSON, внедрённое в СУБД PostgreSQL в версии 9.4.18.
Фактически, JSONB является бинарным представлением JSON [28] , с тем различием, что в хранимых строках пробелы удаляются, сортировка объектов не сохраняется и сохраняется только последнее значение для ключей-дубликатов [29] .  См. также [ править | править код ]  BSON  YAML  JSON-LD  JSONP  Примечания [ править | править код ]    ↑  Crockford D.  The application/json Media Type for JavaScript Object Notation (JSON)  (англ.) — Internet Engineering Task Force , 2006. — 10 p. — doi:10.17487/RFC4627   ↑  Doug Crockford "Google Tech Talks: JavaScript: The Good Parts"  (неопр.) (7 февраля 2009).   ↑  JSON Redux AKA RFC7159  (неопр.) .   ↑  http://jsonrpc.org/historical/json-rpc-1-1-alt.html#service-procedure-and-parameter-names   ↑  JSON5 by aseemk   ↑  In The Wild · json5/json5 Wiki · GitHub   ↑  YAML Ain’t Markup Language (YAML™) Version 1.2  (англ.)  (недоступная ссылка) . — Working Draft 2008-05-11. Дата обращения: 24 сентября 2009.  Архивировано 16 мая 2008 года.   ↑  YAML is JSON  (неопр.) .  RedHanded (7 апреля 2005). Дата обращения: 25 сентября 2012. .   ↑  Json.Com.  JSON Schema Proposal  (англ.)  (недоступная ссылка) . Архивировано 14 мая 2008 года.   ↑  JSON-LD Syntax 1.0  (неопр.) (27 декабря 2011). Дата обращения: 30 декабря 2011.   ↑  RFC 4627 (Request for Comments)   ↑  JSON: Обезжиренная альтернатива XML  (англ.) . Архивировано 12 февраля 2012 года.   ↑  json2.js  (англ.) . Дата обращения: 24 сентября 2009.  Архивировано 12 февраля 2012 года.   ↑  Использование встроенного JSON  (англ.)  (недоступная ссылка) . Дата обращения: 1 июля 2009.  Архивировано 5 марта 2012 года.   ↑  Встроенный JSON в IE8  (англ.) . Архивировано 12 февраля 2012 года.   ↑  Web-спецификации, поддерживаемые в Opera Presto 2.5  (англ.) (10 March 2010). Дата обращения: 29 марта 2010.  Архивировано 12 февраля 2012 года.   ↑  Реализация ES 3.1 объекта JSON  (англ.) .   ↑  Ticket #4429lang=en  (неопр.) . Архивировано 12 февраля 2012 года.   ↑  Ticket #4429  (неопр.) (22 мая 2009). Дата обращения: 3 июля 2009.  Архивировано 12 февраля 2012 года.   ↑  Ticket #8111lang=en  (неопр.) . Архивировано 12 февраля 2012 года.   ↑  MooTools Core & More 1.3.1  (неопр.) . Архивировано 12 февраля 2012 года.   ↑  YUI 2: JSON utility  (неопр.) (1 сентября 2009). Дата обращения: 22 октября 2009.  Архивировано 12 февраля 2012 года.   ↑  Learn JSON  (неопр.) (7 апреля 2010). Дата обращения: 7 апреля 2010.  Архивировано 12 февраля 2012 года.   ↑  Джереми Гроссмэн.  Продвинутые техники атак на веб-приложения, использующие GMail  (англ.) .  WhiteHat Security. Дата обращения: 23 сентября 2009.  Архивировано 12 февраля 2012 года.   ↑  from __future__ import * » Remote JSON - JSONP  (неопр.) .  Bob.pythonmac.org. Дата обращения: 8 сентября 2008.  Архивировано 12 февраля 2012 года.   ↑  Almeida, Jonas.  JSON, JSONP, JSONPP?  (неопр.) . — S3DB, 2008. — 11 June.   ↑  RIAspot.  JSON P for Cross Site XHR  (неопр.)  (недоступная ссылка) . Архивировано 5 декабря 2008 года.   ↑  Когда использовать неструктурированные типы данных в PostgreSQL? Сравнение Hstore vs. JSON vs. JSONB  (рус.) . Дата обращения 4 июля 2018.   ↑  Чем PostgreSQL лучше других SQL баз данных с открытым исходным кодом. Часть 1  (рус.) . Дата обращения 4 июля 2018.    Ссылки [ править | править код ]  Официальная домашняя страница формата на русском языке  json-rpc.org  Архивная копия от 29 декабря 2014 на Wayback Machine  (англ.)  Глава о JSON из онлайн-учебника JavaScript  (рус.)  Языки разметки документов Офисные документы  Compound Document Format  OOXML ( SpreadsheetML , PresentationML , WordprocessingML )  ODF  UOF  Общеизвестные  CSV  HTML  XML  XHTML  MathML  RTF  TeX  LaTeX  Markdown  Вики-разметка  Менее известные  AsciiDoc  CML  C-HTML  ConTeXt  Crossmark  DITA  DocBook  eLML  EAD  Enriched text  FHTML  GML  GuideML  HDML  HyTime  HyperTeX  IPF  FictionBook  LilyPond  LinuxDoc  Lout  MIF  MAML  MEI  MusicXML  OMDoc  OpenMath  POD  RTML  RTML  RFT  S1000D  TEI  Texinfo  troff  WML  WapTV  XAML  YAML  Z Format   Веб и веб-сайты Глобально  Всемирная паутина  Веб 1.0  Веб 2.0  Веб 3.0  Семантическая паутина  Нейронет  Локально  Сайт  Портал  Страница  Служба  Кольцо  Виды сайтов и сервисов  Виртуальный атлас  Баннерная сеть  Библиотека  Блог ( платформа )  Видеохостинг  Вики  Сайт-визитка  Вопрос-ответ  Закладки  Службы знакомств  Браузерная игра  Каталог ресурсов  Интернет-магазин  Микроблог  Новостной сайт  Поисковая система  Порносайт  Веб-почта  Социальная сеть  Тамблелог  BitTorrent-трекер  Файлообменник  Форум  Сервис  Имиджборд  Фотохостинг  Чат  Создание и обслуживание  Мастер  Разработка  Дизайн  Вёрстка  Программирование  Юзабилити  Опыт взаимодействия  Продвижение сайта  Поисковая оптимизация (SEO)  Хостинг  Системный администратор  Модератор  Учётная запись  Авторизация  Типы макетов, страниц, сайтов  Статический  Динамический  Фиксированный  Резиновый  Динамично эластичный  Адаптивный  Техническое  Веб-сервер ( сравнение )  Браузер  DNS  CMF  CMS  HTTP ( ответы  заголовки )  SPDY  QUIC  CGI  HTML  XHTML  CSS  PHP  JavaScript  DHTML  Cookie  DOM  XML  AJAX  JSON  Flash  RSS  Atom  Информер  Микроформат  favicon .ico  robots.txt  Sitemaps  Карта сайта  .htaccess  Маркетинг  Интернет-маркетинг  Интернет-реклама  Баннер  Контекстная реклама  Тизер  Киберсквоттинг  Социум и культура  Блогосфера  Интернет-сообщество ( районное )  Сетевая литература       Источник — https://ru.wikipedia.org/w/index.php?title=JSON&oldid=112123618  Категории : Форматы файлов Веб-программирование AJAX JavaScript Скрытые категории: Страницы, использующие устаревший тег source Википедия:Статьи с некорректным использованием шаблонов:Cite web (не указан язык) Страницы, использующие волшебные ссылки RFC Википедия:Статьи с источниками из Викиданных ПРО:ИТ:Статьи по алфавиту ПРО:ИТ:Последняя правка: в текущем году Википедия:Статьи с разделами без ссылок на источники с мая 2018 года Википедия:Статьи без источников (тип: формат файла) Википедия:Статьи без источников (не распределённые по типам) Статьи с примерами кода JavaScript        Навигация      Персональные инструменты    Вы не представились системе Обсуждение Вклад Создать учётную запись Войти        Пространства имён    Статья Обсуждение        Варианты            Просмотры    Читать Править Править код История        Ещё         Поиск                     Навигация    Заглавная страница Рубрикация Указатель А — Я Избранные статьи Случайная страница Текущие события       Участие    Сообщить об ошибке Сообщество Форум Свежие правки Новые страницы Справка Пожертвовать       Инструменты    Ссылки сюда Связанные правки Служебные страницы Постоянная ссылка Сведения о странице Цитировать страницу Элемент Викиданных       Печать/экспорт    Создать книгу Скачать как PDF Версия для печати       В других проектах    Викисклад       На других языках    العربية Azərbaycanca Български Català Čeština Deutsch Ελληνικά English Español Eesti Euskara فارسی Suomi Français Galego עברית हिन्दी Magyar Հայերեն Bahasa Indonesia Italiano 日本語 한국어 Кыргызча Lietuvių Latviešu മലയാളം Bahasa Melayu Nederlands Norsk bokmål Polski Português Română Simple English Shqip Српски / srpski Svenska தமிழ் ไทย Türkçe Українська Oʻzbekcha/ўзбекча Tiếng Việt 中文  Править ссылки        Эта страница в последний раз была отредактирована 2 февраля 2021 в 09:48.  Текст доступен по лицензии Creative Commons Attribution-ShareAlike ; в отдельных случаях могут действовать дополнительные условия. Подробнее см. Условия использования . Wikipedia® — зарегистрированный товарный знак некоммерческой организации Wikimedia Foundation, Inc.    Политика конфиденциальности  Описание Википедии  Отказ от ответственности  Свяжитесь с нами  Мобильная версия  Разработчики  Статистика  Заявление о куки           